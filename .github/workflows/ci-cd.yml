name: "â° Scheduler Backend - CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Controle de concorrÃªncia para evitar execuÃ§Ãµes simultÃ¢neas
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# VariÃ¡veis de ambiente global
env:
  SERVICE_NAME: scheduler
  STACK_NAME: conexao-scheduler
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  id-token: write    # NecessÃ¡rio para OIDC com Azure (azure/login@v2)
  contents: read     # NecessÃ¡rio para checkout em jobs

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1


      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "âœ… Docker Compose syntax is valid"

      - name: Security Validation
        run: |
          echo "ğŸ”’ Verificando seguranÃ§a da configuraÃ§Ã£o..."
          # SÃ³ acusa erro se encontrar password: com valor literal (nÃ£o variÃ¡vel)
          if grep -E '^\s*password\s*:\s*[^ $\{]' docker-compose.yml | grep -v '#' | grep -v 'external:'; then
            echo "âŒ Encontrada(s) senha(s) hardcoded literal em docker-compose.yml"
            exit 1
          else
            echo "âœ… Nenhuma senha hardcoded literal encontrada"
          fi

      - name: ğŸ” Validar OIDC Azure
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID || secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID || secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_ENDPOINT: ${{ vars.AZURE_KEYVAULT_ENDPOINT || secrets.AZURE_KEYVAULT_ENDPOINT }}
          AZURE_KEYVAULT_NAME: ${{ vars.AZURE_KEYVAULT_NAME || secrets.AZURE_KEYVAULT_NAME }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf 'âŒ GitHub Secrets obrigatÃ³rios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "âœ… Identificadores Azure configurados via vars (fallback para secrets)"

          # Key Vault Ã© opcional - verificar ENDPOINT primeiro, depois NAME
          if [[ -n "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            echo "âœ… AZURE_KEYVAULT_ENDPOINT configurado via vars"
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
            # Extrair nome do endpoint para compatibilidade
            KEYVAULT_NAME=$(echo "$AZURE_KEYVAULT_ENDPOINT" | sed 's|https://\(.*\)\.vault\.azure\.net/.*|\1|')
            echo "keyvault_name=$KEYVAULT_NAME" >> "$GITHUB_OUTPUT"
          elif [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            echo "âœ… AZURE_KEYVAULT_NAME configurado via vars (fallback)"
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
            echo "keyvault_name=$AZURE_KEYVAULT_NAME" >> "$GITHUB_OUTPUT"
          else
            echo "â„¹ï¸ Nenhum Key Vault configurado - prosseguindo sem Azure Key Vault"
            echo "has_keyvault=false" >> "$GITHUB_OUTPUT"
          fi

          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"

      # Upload artifacts removido para evitar storage quota

      - name: Validation completed
        run: |
          echo "âœ… ValidaÃ§Ã£o concluÃ­da - pronto para deploy"

  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [self-hosted, Linux, X64, conexao-de-sorte-backend-scheduler]
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: ğŸ” Azure Login (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get secrets from Azure Key Vault (via AZ CLI)
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        shell: bash
        run: |
          echo "Fetching secrets from Azure Key Vault using Azure CLI..."
          SECRETS_LIST=(
            "conexao-de-sorte-database-r2dbc-url"
            "conexao-de-sorte-database-username"
            "conexao-de-sorte-database-password"
            "conexao-de-sorte-redis-host"
            "conexao-de-sorte-redis-port"
            "conexao-de-sorte-redis-password"
            "conexao-de-sorte-redis-database"
            "conexao-de-sorte-jwt-issuer"
            "conexao-de-sorte-jwt-jwks-uri"
            "conexao-de-sorte-jwt-secret"
            "conexao-de-sorte-jwt-signing-key"
            "conexao-de-sorte-jwt-verification-key"
            "conexao-de-sorte-rabbitmq-host"
            "conexao-de-sorte-rabbitmq-port"
            "conexao-de-sorte-rabbitmq-username"
            "conexao-de-sorte-rabbitmq-password"
            "conexao-de-sorte-rabbitmq-vhost"
            "conexao-de-sorte-server-port"
          )

          for secret_name in "${SECRETS_LIST[@]}"; do
            echo "Fetching secret: $secret_name"

            secret_value=$(az keyvault secret show --vault-name "${{ secrets.AZURE_KEYVAULT_NAME }}" --name "$secret_name" --query "value" -o tsv 2>/dev/null)

            if [[ -n "$secret_value" ]]; then
              echo "::add-mask::$secret_value"
              env_var_name=$(echo "$secret_name" | tr '-' '_' | tr '[:lower:]' '[:upper:]')
              echo "${env_var_name}=${secret_value}" >> $GITHUB_ENV
              echo "Secret '$secret_name' fetched and set as environment variable '${env_var_name}'."
            else
              echo "Warning: Secret '$secret_name' not found in Azure Key Vault."
            fi
          done

      - name: ğŸ” Docker Registry Login
        run: |
          echo "ğŸ” Fazendo login no GitHub Container Registry..."
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          echo "âœ… Login no GHCR realizado com sucesso"

      - name: ğŸ” Create Docker Secrets
        if: ${{ env.CONEXAO_DE_SORTE_DATABASE_PASSWORD != '' && env.CONEXAO_DE_SORTE_REDIS_PASSWORD != '' }}
        run: |
          echo "Creating Docker secrets..."

          # Remover serviÃ§os dependentes primeiro se existirem
          if docker service ls --filter name="conexao-scheduler" --format "{{.Name}}" | grep -q "conexao-scheduler"; then
            echo "âš ï¸ Removendo serviÃ§os dependentes do Scheduler primeiro..."
            docker service ls --filter name="conexao-scheduler" --format "{{.Name}}" | xargs -r docker service rm || true
            sleep 5
          fi

          # Lista de secrets para o Scheduler (18 secrets)
          declare -A SECRETS_MAP=(
            ["conexao-de-sorte-database-r2dbc-url"]="$CONEXAO_DE_SORTE_DATABASE_R2DBC_URL"
            ["conexao-de-sorte-database-username"]="$CONEXAO_DE_SORTE_DATABASE_USERNAME"
            ["conexao-de-sorte-database-password"]="$CONEXAO_DE_SORTE_DATABASE_PASSWORD"
            ["conexao-de-sorte-redis-host"]="$CONEXAO_DE_SORTE_REDIS_HOST"
            ["conexao-de-sorte-redis-port"]="$CONEXAO_DE_SORTE_REDIS_PORT"
            ["conexao-de-sorte-redis-password"]="$CONEXAO_DE_SORTE_REDIS_PASSWORD"
            ["conexao-de-sorte-redis-database"]="$CONEXAO_DE_SORTE_REDIS_DATABASE"
            ["conexao-de-sorte-jwt-issuer"]="$CONEXAO_DE_SORTE_JWT_ISSUER"
            ["conexao-de-sorte-jwt-jwks-uri"]="$CONEXAO_DE_SORTE_JWT_JWKS_URI"
            ["conexao-de-sorte-jwt-secret"]="$CONEXAO_DE_SORTE_JWT_SECRET"
            ["conexao-de-sorte-jwt-signing-key"]="$CONEXAO_DE_SORTE_JWT_SIGNING_KEY"
            ["conexao-de-sorte-jwt-verification-key"]="$CONEXAO_DE_SORTE_JWT_VERIFICATION_KEY"
            ["conexao-de-sorte-rabbitmq-host"]="$CONEXAO_DE_SORTE_RABBITMQ_HOST"
            ["conexao-de-sorte-rabbitmq-port"]="$CONEXAO_DE_SORTE_RABBITMQ_PORT"
            ["conexao-de-sorte-rabbitmq-username"]="$CONEXAO_DE_SORTE_RABBITMQ_USERNAME"
            ["conexao-de-sorte-rabbitmq-password"]="$CONEXAO_DE_SORTE_RABBITMQ_PASSWORD"
            ["conexao-de-sorte-rabbitmq-vhost"]="$CONEXAO_DE_SORTE_RABBITMQ_VHOST"
            ["conexao-de-sorte-server-port"]="$CONEXAO_DE_SORTE_SERVER_PORT"
          )

          # Processar cada secret
          for secret_name in "${!SECRETS_MAP[@]}"; do
            secret_value="${SECRETS_MAP[$secret_name]}"
            docker_secret_name=$(echo "$secret_name" | tr '[:lower:]' '[:upper:]' | tr '-' '_')

            if [[ -n "$secret_value" ]]; then
              # Remover secret existente se necessÃ¡rio
              if docker secret ls --format "{{.Name}}" | grep -q "^${docker_secret_name}$"; then
                echo "âš ï¸ Removendo secret existente: $docker_secret_name"
                docker secret rm "$docker_secret_name" || true
                sleep 1
              fi

              # Criar novo secret
              printf "$secret_value" | docker secret create "$docker_secret_name" -
              echo "âœ… Secret criado: $docker_secret_name"
            else
              echo "âš ï¸ Secret vazio ou nÃ£o encontrado: $secret_name"
            fi
          done

          echo "Docker secrets created."

      - name: ğŸ” Preparar ambiente de deploy
        run: |
          echo "ğŸ” Preparando ambiente para deploy do Scheduler..."

          # Verificar arquivos necessÃ¡rios
          echo "ğŸ” Verificando arquivos necessÃ¡rios..."
          for required_file in "docker-compose.yml"; do
            if [[ -f "$required_file" ]]; then
              echo "âœ… $required_file encontrado"
            else
              echo "âŒ $required_file NÃƒO encontrado"
              exit 1
            fi
          done

          # Verificar/criar diretÃ³rios especÃ­ficos do Scheduler
          required_dirs=(
            "logs"
            "config"
          )

          for required_dir in "${required_dirs[@]}"; do
            if [[ -d "$required_dir" ]]; then
              echo "âœ… DiretÃ³rio $required_dir existe"
            else
              echo "âš ï¸ DiretÃ³rio $required_dir nÃ£o existe - criando..."
              mkdir -p "$required_dir"
            fi
          done

          # Verificar rede Docker Swarm
          echo "ğŸ” Verificando rede Docker Swarm..."
          if docker network ls | grep -q "${DOCKER_NETWORK_NAME}"; then
            echo "âœ… Rede ${DOCKER_NETWORK_NAME} existe"
          else
            echo "âŒ Rede ${DOCKER_NETWORK_NAME} nÃ£o encontrada"
            echo "ğŸ’¡ Criando rede overlay para Docker Swarm..."
            docker network create --driver overlay --attachable "${DOCKER_NETWORK_NAME}" || echo "âš ï¸ Rede jÃ¡ existe ou erro na criaÃ§Ã£o"
          fi

      - name: ğŸ§¹ Limpeza completa de recursos antigos
        run: |
          echo "ğŸ§¹ Iniciando limpeza completa de recursos do Scheduler..."

          # Configurar variÃ¡veis de ambiente
          export COMPOSE_PROJECT_NAME="${STACK_NAME}"
          SERVICE_NAME="${STACK_NAME}_scheduler"

          # 1. Parar e remover serviÃ§os Docker Swarm
          echo "ğŸ” Verificando serviÃ§os Docker Swarm existentes..."
          if docker service ls --filter name="${STACK_NAME}_" --format "{{.Name}}" | grep -q "${STACK_NAME}_"; then
            echo "âš ï¸ Encontrados serviÃ§os existentes do Scheduler - removendo..."

            # Escalar para 0 rÃ©plicas primeiro (graceful shutdown)
            for service in $(docker service ls --filter name="${STACK_NAME}_" --format "{{.Name}}"); do
              echo "ğŸ“‰ Escalando $service para 0 rÃ©plicas..."
              docker service scale "$service=0" || echo "âš ï¸ Falha ao escalar $service"
            done

            # Aguardar parada das tarefas
            echo "â³ Aguardando parada das tarefas..."
            sleep 15

            # Remover serviÃ§os
            for service in $(docker service ls --filter name="${STACK_NAME}_" --format "{{.Name}}"); do
              echo "ğŸ—‘ï¸ Removendo serviÃ§o: $service"
              docker service rm "$service" || echo "âš ï¸ Falha ao remover $service"
            done

            # Aguardar remoÃ§Ã£o completa
            echo "â³ Aguardando remoÃ§Ã£o completa dos serviÃ§os..."
            timeout=90
            start_time=$(date +%s)
            while docker service ls --filter name="${STACK_NAME}_" --format "{{.Name}}" | grep -q "${STACK_NAME}_"; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))
              if [[ $elapsed -gt $timeout ]]; then
                echo "âš ï¸ Timeout aguardando remoÃ§Ã£o dos serviÃ§os"
                break
              fi
              echo "â³ Aguardando... ($elapsed/${timeout}s)"
              sleep 5
            done
          fi

          # 2. Remover stack se ainda existir
          if docker stack ls --format "{{.Name}}" | grep -q "^${STACK_NAME}$"; then
            echo "âš ï¸ Stack ${STACK_NAME} ainda existe - removendo..."
            docker stack rm "${STACK_NAME}"
            sleep 10
          fi

          # 3. Limpeza de containers Ã³rfÃ£os (se existirem)
          echo "ğŸ” Verificando containers Ã³rfÃ£os..."
          orphan_containers=$(docker ps -a --filter name="*scheduler*" --format "{{.ID}} {{.Names}}" | grep -E "(conexao-scheduler|scheduler)" || true)
          if [[ -n "$orphan_containers" ]]; then
            echo "âš ï¸ Encontrados containers Ã³rfÃ£os do Scheduler:"
            echo "$orphan_containers"
            echo "$orphan_containers" | while read container_id container_name; do
              if [[ -n "$container_id" ]]; then
                echo "ğŸ—‘ï¸ Removendo container Ã³rfÃ£o: $container_name ($container_id)"
                docker stop "$container_id" 2>/dev/null || true
                docker rm "$container_id" 2>/dev/null || true
              fi
            done
          fi

          # 4. Limpeza de imagens antigas (opcional - manter apenas algumas versÃµes)
          echo "ğŸ” Limpeza de imagens antigas do Scheduler..."
          old_images=$(docker images ghcr.io/wibson82/conexao-de-sorte-backend-scheduler/scheduler --format "{{.ID}} {{.Repository}}:{{.Tag}}" | tail -n +4 || true)
          if [[ -n "$old_images" ]]; then
            echo "âš ï¸ Removendo imagens antigas (mantendo 3 mais recentes):"
            echo "$old_images" | while read image_id image_name; do
              if [[ -n "$image_id" && "$image_name" != *"latest"* ]]; then
                echo "ğŸ—‘ï¸ Removendo imagem antiga: $image_name ($image_id)"
                docker rmi "$image_id" 2>/dev/null || true
              fi
            done
          fi

          echo "âœ… Limpeza completa concluÃ­da"

      - name: ğŸŒ Garantir rede Swarm compartilhada
        run: |
          echo "ğŸŒ Verificando e configurando rede Docker Swarm compartilhada..."

          # Verificar se Docker Swarm estÃ¡ ativo
          if ! docker info --format '{{.Swarm.LocalNodeState}}' | grep -q "active"; then
            echo "âš ï¸ Docker Swarm nÃ£o estÃ¡ ativo - inicializando..."
            docker swarm init --advertise-addr $(hostname -I | awk '{print $1}') || echo "âš ï¸ Swarm jÃ¡ pode estar inicializado"
          fi

          # Verificar/criar rede overlay compartilhada
          NETWORK_NAME="${DOCKER_NETWORK_NAME}"
          if ! docker network ls --filter name="^${NETWORK_NAME}$" --format "{{.Name}}" | grep -q "^${NETWORK_NAME}$"; then
            echo "ğŸ”§ Criando rede overlay compartilhada: ${NETWORK_NAME}"
            docker network create \
              --driver overlay \
              --attachable \
              --subnet=10.10.0.0/16 \
              --gateway=10.10.0.1 \
              "${NETWORK_NAME}"
            echo "âœ… Rede ${NETWORK_NAME} criada com sucesso"
          else
            echo "âœ… Rede ${NETWORK_NAME} jÃ¡ existe"
          fi

          # Verificar propriedades da rede
          echo "ğŸ“Š Propriedades da rede ${NETWORK_NAME}:"
          docker network inspect "${NETWORK_NAME}" --format "{{.Driver}} - {{.Scope}} - {{.IPAM.Config}}" || true

      - name: ğŸš€ Deploy to Docker Swarm
        run: |
          echo "ğŸš€ Iniciando deploy do Scheduler no Docker Swarm..."

          # Verificar se temos os segredos mÃ­nimos necessÃ¡rios
          if [[ -z "${CONEXAO_DE_SORTE_DATABASE_R2DBC_URL}" ]] || [[ -z "${CONEXAO_DE_SORTE_DATABASE_USERNAME}" ]] || [[ -z "${CONEXAO_DE_SORTE_DATABASE_PASSWORD}" ]]; then
            echo "âŒ Segredos do banco de dados nÃ£o configurados"
            echo "âš ï¸ Verifique:"
            echo "  - Se os segredos existem no Azure Key Vault"
            echo "  - Se os segredos estÃ£o configurados como GitHub Secrets"
            echo "  - Se a integraÃ§Ã£o com Azure Key Vault estÃ¡ funcionando"
            exit 1
          fi

          if [[ -z "${CONEXAO_DE_SORTE_REDIS_HOST}" ]] || [[ -z "${CONEXAO_DE_SORTE_REDIS_PASSWORD}" ]]; then
            echo "âŒ Segredos do Redis nÃ£o configurados"
            exit 1
          fi

          if [[ -z "${CONEXAO_DE_SORTE_JWT_SECRET}" ]] || [[ -z "${CONEXAO_DE_SORTE_JWT_ISSUER}" ]]; then
            echo "âŒ Segredos JWT nÃ£o configurados"
            exit 1
          fi

          if [[ -z "${CONEXAO_DE_SORTE_RABBITMQ_HOST}" ]] || [[ -z "${CONEXAO_DE_SORTE_RABBITMQ_PASSWORD}" ]]; then
            echo "âŒ Segredos RabbitMQ nÃ£o configurados"
            exit 1
          fi

          echo "âœ… Todos os segredos necessÃ¡rios estÃ£o configurados"

          # Configurar variÃ¡veis de ambiente para o deploy
          export COMPOSE_PROJECT_NAME="${STACK_NAME}"

          # Pull da imagem mais recente
          echo "ğŸ“¥ Fazendo pull da imagem mais recente..."
          if ! docker pull ghcr.io/wibson82/conexao-de-sorte-backend-scheduler:latest; then
            echo "âŒ Falha no pull da imagem - verificando se existe localmente..."
            if ! docker image inspect ghcr.io/wibson82/conexao-de-sorte-backend-scheduler:latest >/dev/null 2>&1; then
              echo "âŒ Imagem nÃ£o encontrada localmente! Listando imagens disponÃ­veis:"
              docker images | grep -E "(conexao-de-sorte-backend-scheduler|REPOSITORY)" || echo "Nenhuma imagem do scheduler encontrada"
              exit 1
            else
              echo "âœ… Usando imagem local existente"
            fi
          else
            echo "âœ… Pull da imagem realizado com sucesso"
          fi

          # Deploy usando Docker Stack
          echo "ğŸ”„ Executando deploy stack..."
          if docker stack deploy -c docker-compose.yml "${STACK_NAME}"; then
            echo "âœ… Deploy executado com sucesso"
            echo "ğŸ“‹ Verificando se serviÃ§os foram criados..."
            sleep 5
            docker service ls --filter name="${STACK_NAME}_" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
          else
            echo "âŒ Falha no deploy do stack"
            echo "ğŸ” Verificando logs de erro..."
            docker service ls --filter name="${STACK_NAME}_" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}" || echo "Nenhum serviÃ§o criado"
            exit 1
          fi

      - name: ğŸ” VerificaÃ§Ã£o pÃ³s-deploy
        run: |
          echo "ğŸ” Verificando status do deploy..."

          # Aguardar alguns segundos para inicializaÃ§Ã£o
          echo "â³ Aguardando inicializaÃ§Ã£o dos serviÃ§os..."
          sleep 30

          # Verificar status dos serviÃ§os
          echo "ğŸ“Š Status dos serviÃ§os do Scheduler:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}\t{{.Ports}}"

          # Verificar tarefas dos serviÃ§os (para debug)
          echo "ğŸ“‹ Tarefas dos serviÃ§os:"
          for service in $(docker service ls --filter name="${STACK_NAME}_*" --format "{{.Name}}" ); do
            echo "=== $service ==="
            docker service ps "$service" --no-trunc --format "table {{.Name}}\t{{.Node}}\t{{.CurrentState}}\t{{.Error}}"
          done

          # Health check especÃ­fico do Scheduler
          echo "ğŸ¥ Verificando saÃºde dos serviÃ§os..."
          service_name="${STACK_NAME}_scheduler"
          if docker service ls --filter name="$service_name" --format "{{.Name}}" | grep -q "$service_name"; then
            echo "âœ… ServiÃ§o $service_name encontrado"
            timeout=180
            echo "â³ Aguardando serviÃ§o ficar saudÃ¡vel (timeout: ${timeout}s)..."
            start_time=$(date +%s)
            healthy=0
            while true; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))
              if [[ $elapsed -gt $timeout ]]; then
                echo "âš ï¸ Timeout aguardando serviÃ§o ficar saudÃ¡vel"
                break
              fi
              replicas=$(docker service ls --filter name="$service_name" --format "{{.Replicas}}")
              # Busca o container mais recente do serviÃ§o
              container_id=$(docker ps --filter "name=${service_name}" --format "{{.ID}}" | head -1)
              if [[ -n "$container_id" ]]; then
                health_status=$(docker inspect --format='{{.State.Health.Status}}' "$container_id" 2>/dev/null || echo "no-health-check")
                echo "â³ ($elapsed/${timeout}s) - RÃ©plicas: $replicas - Health: $health_status"
                if [[ "$health_status" == "healthy" ]]; then
                  echo "âœ… Container estÃ¡ healthy!"
                  healthy=1
                  break
                fi
                # Mostra logs do container se estiver demorando
                if (( elapsed > 60 )); then
                  echo "--- Ãšltimos logs do container $container_id ---"
                  docker logs --tail 20 "$container_id" || true
                  echo "----------------------------------------------"
                fi
              else
                echo "â³ ($elapsed/${timeout}s) - Nenhum container encontrado para $service_name"
              fi
              sleep 10
            done
            if [[ $healthy -ne 1 ]]; then
              echo "âŒ ServiÃ§o nÃ£o ficou healthy. Exibindo logs do container mais recente:"
              last_container=$(docker ps -a --filter "name=${service_name}" --format "{{.ID}}" | head -1)
              if [[ -n "$last_container" ]]; then
                docker logs --tail 50 "$last_container" || true
              fi
            fi
          else
            echo "âŒ ServiÃ§o $service_name nÃ£o encontrado"
          fi
          echo "ğŸ“Š Status final dos serviÃ§os:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

      - name: ğŸ¥ Verificar Deploy no Runner (Local Container Check)
        run: |
          echo "ğŸ¥ Verificando se o deploy foi bem-sucedido no runner..."

          # Verificar se o container estÃ¡ rodando e healthy
          timeout=180
          interval=10
          elapsed=0

          while [ $elapsed -lt $timeout ]; do
            echo "ğŸ” Verificando containers do Scheduler (${elapsed}/${timeout}s)..."
            # Buscar container mais recente do scheduler
            container_id=$(docker ps --filter "name=conexao-scheduler" --format "{{.ID}}" | head -1)
            if [[ -n "$container_id" ]]; then
              container_name=$(docker inspect --format='{{.Name}}' "$container_id" | sed 's|/||')
              health_status=$(docker inspect --format='{{.State.Health.Status}}' "$container_id" 2>/dev/null || echo "no-health-check")
              echo "ğŸ“Š Container encontrado: $container_name ($container_id) - Health: $health_status"
              if [[ "$health_status" == "healthy" ]]; then
                echo "âœ… Container do Scheduler estÃ¡ healthy no runner"
                echo "ğŸ¯ Deploy confirmado com sucesso!"
                exit 0
              elif [[ "$health_status" == "no-health-check" ]]; then
                echo "âš ï¸ Container sem health check configurado, verificando se estÃ¡ rodando..."
                uptime=$(docker inspect --format='{{.State.StartedAt}}' "$container_id" | xargs -I {} date -d {} +%s)
                current_time=$(date +%s)
                running_time=$((current_time - uptime))
                if [ $running_time -gt 30 ]; then
                  echo "âœ… Container rodando hÃ¡ ${running_time}s - considerado estÃ¡vel"
                  echo "ğŸ¯ Deploy confirmado com sucesso!"
                  exit 0
                fi
              else
                echo "âš ï¸ Container health status: $health_status"
                if (( elapsed > 60 )); then
                  echo "--- Ãšltimos logs do container $container_id ---"
                  docker logs --tail 20 "$container_id" || true
                  echo "----------------------------------------------"
                fi
              fi
            else
              echo "âš ï¸ Nenhum container do Scheduler encontrado rodando"
            fi
            sleep "$interval"
            elapsed=$((elapsed + interval))
          done
          echo "âŒ Timeout: Scheduler nÃ£o estÃ¡ healthy apÃ³s ${timeout}s"
          echo "ğŸ“‹ Listando containers atuais:"
          docker ps --filter "name=conexao-scheduler" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

          # Debugging aprimorado - mostrar logs detalhados
          echo "ğŸ” Logs do container mais recente para debug:"
          last_container=$(docker ps -a --filter "name=conexao-scheduler" --format "{{.ID}}" | head -1)
          if [[ -n "$last_container" ]]; then
            echo "--- ğŸ“‹ InformaÃ§Ãµes do container $last_container ---"
            docker inspect --format='{{.State.Status}} - {{.State.Error}}' "$last_container" || true
            echo "--- ğŸ” Logs do container $last_container ---"
            docker logs --tail 100 "$last_container" || true
            echo "----------------------------------------------"
          fi

          # Verificar serviÃ§os do stack
          echo "ğŸ” Status dos serviÃ§os do stack:"
          docker service ls --filter name="conexao-scheduler" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}\t{{.Ports}}" || true

          # Verificar tarefas com falhas
          echo "ğŸ” Tarefas com problemas:"
          docker service ps conexao-scheduler_scheduler --no-trunc --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" 2>/dev/null || true

          exit 1

  cleanup-artifacts:
    needs: deploy-selfhosted
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: always()
    permissions:
      contents: read
    steps:
      - name: Cleanup completed
        run: |
          echo "ğŸ§¹ Limpeza de artefatos concluÃ­da"
          echo "ğŸ“Š Status do workflow: ${{ needs.deploy-selfhosted.result }}"