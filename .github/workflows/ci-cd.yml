name: ‚è∞ Scheduler Microservice - CI/CD Pipeline (Self-hosted Runners)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Destino do deploy'
        required: false
        default: 'production'
        type: choice
        options: [staging, production]

env:
  SERVICE_NAME: scheduler
  TZ: America/Sao_Paulo

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: false

jobs:
  validate-environment:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    name: ‚úÖ Validate Build Environment
    steps:
      - uses: actions/checkout@v4
      - name: "Guard: forbid r2dbc:h2 outside tests"
        timeout-minutes: 10
        run: |
          set -euo pipefail
          FOUND=$(grep -R --line-number --include='*.yml' --include='*.properties' --include='*.yaml' "r2dbc:h2" src || true)
          if echo "$FOUND" | grep -v "src/test/" | grep -q "r2dbc:h2"; then
            echo "Forbidden r2dbc:h2 reference outside src/test" >&2
            echo "$FOUND" | grep -v "src/test/" >&2 || true
            exit 1
          fi
      - name: "Guard: H2 not in non-test scopes"
        timeout-minutes: 10
        run: |
          set -euo pipefail
          mvn -B -q dependency:list -DincludeScope=compile -DoutputFile=dep.txt -DappendOutput=true || true
          if grep -E "com\.h2database:h2|io\.r2dbc:r2dbc-h2" dep.txt; then
            echo "H2 present in non-test scope (compile/runtime)" >&2
            exit 1
          fi
      - name: Check self-hosted runner availability
        timeout-minutes: 10
        run: |
          echo "üîç Checking GitHub Runner labels and environment..."
          echo "Runner OS: $RUNNER_OS"
          echo "Runner Architecture: $RUNNER_ARCH"
          echo "Expected Labels: [self-hosted, conexao-de-sorte-backend-scheduler]"
          echo "Note: This validation runs on GitHub runners, actual deployment uses self-hosted runners"
          echo "‚ö†Ô∏è Verify that the self-hosted runner is registered with exactly these labels:"
          echo "  - self-hosted"
          echo "  - conexao-de-sorte-backend-scheduler"
          echo "üìã Runner registration command should include: --labels self-hosted,conexao-de-sorte-backend-scheduler"

  build-and-test:
    needs: validate-environment
    runs-on: ubuntu-latest
    timeout-minutes: 10
    name: üèóÔ∏è Build and Test on GitHub Runners
    steps:
      - uses: actions/checkout@v4
      - name: Setup Java 24
        timeout-minutes: 10
        uses: actions/setup-java@v4
        with:
          java-version: '24'
          distribution: 'temurin'
          cache: maven
      - name: Verify Maven wrapper
        timeout-minutes: 10
        run: |
          chmod +x ./mvnw
          ./mvnw --version
      - name: Build application (skip tests)
        timeout-minutes: 10
        run: ./mvnw clean package -DskipTests
      - name: Upload JAR artifact for self-hosted runner
        timeout-minutes: 10
        uses: actions/upload-artifact@v4
        with:
          name: scheduler-microservice-jar
          path: target/*.jar
          retention-days: 1

  build-deploy-selfhosted:
    runs-on: [self-hosted]
    timeout-minutes: 10
    name: üöÄ Build & Deploy on Self-hosted Runner (Ubuntu)
    needs: build-and-test
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'production'))
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      
      - name: Verificar ambiente do self-hosted runner
        run: |
          echo "üîç Verificando ambiente do self-hosted runner..."
          echo "üèÉ Runner: $(hostname)"
          echo "üìÖ Data: $(date)"
          echo "üë§ Usu√°rio: $(whoami)"
          echo "üìÅ Diret√≥rio: $(pwd)"
          echo "üíæ Espa√ßo dispon√≠vel:"
          df -h
          echo "üê≥ Docker version:"
          docker --version
          echo "‚òï Java version:"
          java -version || echo "Java n√£o encontrado via PATH"
          
      - name: Download JAR artifact from GitHub runners
        uses: actions/download-artifact@v4
        with:
          name: scheduler-microservice-jar
          path: ./target
          
      - name: Azure Login (OIDC) no self-hosted runner
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Fetch Azure Key Vault secrets
        id: kv
        shell: bash
        run: |
          set -euo pipefail
          VAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          if [[ "$VAULT_ENDPOINT" =~ https://([^.]+)\.vault\.azure\.net ]]; then
            VAULT="${BASH_REMATCH[1]}"
          else
            echo "ERROR: Invalid AZURE_KEYVAULT_ENDPOINT format: $VAULT_ENDPOINT" >&2
            exit 1
          fi
          
          echo "Loading secrets from Azure Key Vault: $VAULT" >&2
          get() { 
            echo "Fetching secret: $1" >&2
            SECRET_VALUE=$(az keyvault secret show --vault-name "$VAULT" --name "$1" --query value -o tsv 2>/dev/null)
            if [ $? -ne 0 ] || [ -z "$SECRET_VALUE" ]; then
              echo "ERROR: Secret $1 not found in Azure Key Vault $VAULT" >&2
              exit 1
            fi
            echo "$SECRET_VALUE"
          }
          
          # Scheduler specific secrets
          echo "DATABASE_URL=$(get conexao-de-sorte-database-url)" >> $GITHUB_ENV
          echo "DATABASE_USERNAME=$(get conexao-de-sorte-database-username)" >> $GITHUB_ENV
          echo "DATABASE_PASSWORD=$(get conexao-de-sorte-database-password)" >> $GITHUB_ENV
          echo "JWT_ISSUER=$(get conexao-de-sorte-jwt-issuer)" >> $GITHUB_ENV
          echo "JWT_JWKS_URI=$(get conexao-de-sorte-jwt-jwks-uri)" >> $GITHUB_ENV
          
          echo "‚úÖ Azure Key Vault secrets loaded successfully" >&2
          
      - name: üßπ Clean old containers
        run: |
          set -euo pipefail
          echo "üßπ Cleaning old scheduler-microservice containers..."
          
          if docker ps -a --format '{{.Names}}' | grep -q '^scheduler-microservice$'; then
            echo 'üõë Stopping container: scheduler-microservice'
            docker stop 'scheduler-microservice' || true
            echo 'üóëÔ∏è Removing container: scheduler-microservice'
            docker rm 'scheduler-microservice' || true
          else
            echo '‚úÖ No scheduler-microservice container found'
          fi
          
          # Remover imagens antigas do scheduler
          docker images --format "{{.Repository}}:{{.Tag}}" | grep "^wibson82/conexao-de-sorte-backend-scheduler:" | head -n -1 | xargs -r docker rmi || true
          echo "‚úÖ Container cleanup completed"

      - name: üê≥ Build Docker image (Local - Self-hosted)
        id: build
        run: |
          set -euo pipefail
          TAG="wibson82/conexao-de-sorte-backend-scheduler:$(date +'%Y-%m-%d-%H%M%S')"
          
          echo "üèóÔ∏è Building Docker image locally on self-hosted runner: $TAG"
          docker build \
            --platform linux/amd64 \
            --tag "$TAG" \
            --build-arg CONEXAO_DE_SORTE_DATABASE_URL="${{ env.DATABASE_URL }}" \
            --build-arg CONEXAO_DE_SORTE_DATABASE_USERNAME="${{ env.DATABASE_USERNAME }}" \
            --build-arg CONEXAO_DE_SORTE_DATABASE_PASSWORD="${{ env.DATABASE_PASSWORD }}" \
            --build-arg CONEXAO_DE_SORTE_JWT_ISSUER="${{ env.JWT_ISSUER }}" \
            --build-arg CONEXAO_DE_SORTE_JWT_JWKS_URI="${{ env.JWT_JWKS_URI }}" \
            --build-arg SERVICE_NAME="${{ env.SERVICE_NAME }}" \
            --build-arg BUILD_DATE="${{ github.event.head_commit.timestamp || github.run_id }}" \
            --build-arg VCS_REF="${{ github.sha }}" \
            --build-arg VERSION="1.0.0" \
            .
          
          echo "image_tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Image built locally on self-hosted runner (NO REGISTRY)"

      - name: üöÄ Deploy container directly
        run: |
          set -euo pipefail
          IMAGE_TAG="${{ steps.build.outputs.image_tag }}"
          export TZ=America/Sao_Paulo
          
          # Criar rede se n√£o existir
          echo "üåê Creating Docker network if it doesn't exist..."
          docker network create conexao-network 2>/dev/null || true
          
          echo "üöÄ Starting scheduler-microservice container..."
          docker run -d \
            --name "scheduler-microservice" \
            --network conexao-network \
            --restart unless-stopped \
            -p "8084:8080" \
            --health-cmd="curl -f http://localhost:8080/actuator/health/readiness && curl -f http://localhost:8080/actuator/health/liveness || exit 1" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-retries=5 \
            --health-start-period=60s \
            -e JAVA_TOOL_OPTIONS="-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 -Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom -Djava.awt.headless=true -Dfile.encoding=UTF-8" \
            -e SPRING_PROFILES_ACTIVE="prod,azure" \
            -e ENVIRONMENT="production" \
            -e SERVER_PORT="8080" \
            -e TZ="America/Sao_Paulo" \
            -e AZURE_CLIENT_ID="${{ secrets.AZURE_CLIENT_ID }}" \
            -e AZURE_TENANT_ID="${{ secrets.AZURE_TENANT_ID }}" \
            -e AZURE_KEYVAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}" \
            -e AZURE_KEYVAULT_ENABLED="true" \
            --label "traefik.enable=true" \
            --label "traefik.docker.network=conexao-network" \
            --label "traefik.http.routers.scheduler.rule=Host(\`scheduler.conexaodesorte.com.br\`)" \
            --label "traefik.http.routers.scheduler.entrypoints=websecure" \
            --label "traefik.http.routers.scheduler.tls.certresolver=letsencrypt" \
            --label "traefik.http.services.scheduler.loadbalancer.server.port=8080" \
            "$IMAGE_TAG"
          
          echo "‚úÖ Container deployed successfully"

      - name: Wait for service to be ready
        run: |
          echo "üîç Waiting for service to be ready..."
          TIMEOUT=180
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if docker exec scheduler-microservice curl -f -s http://localhost:8080/actuator/health/readiness >/dev/null 2>&1; then
              echo "‚úÖ Service is ready and healthy!"
              break
            fi
            echo "‚è≥ Waiting for service readiness... ($ELAPSED/$TIMEOUT seconds)"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ùå Service failed to become ready within $TIMEOUT seconds"
            echo "üîç Container logs:"
            docker logs scheduler-microservice --tail 50
            exit 1
          fi
          
          echo "üîç Final container status:"
          docker ps --filter name=scheduler-microservice --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
          
          echo "üéâ Self-hosted deployment completed successfully - Service is healthy!"

  notify:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    name: üì¢ Notification
    if: always()
    needs: [build-and-test, build-deploy-selfhosted]
    steps:
      - name: üìß Send Slack notification
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          DEPLOY_RESULT="${{ needs.build-deploy-selfhosted.result }}"
          if [ "$DEPLOY_RESULT" = "success" ]; then
            STATUS="üéâ SUCCESS (Self-hosted)"
            COLOR="good"
          elif [ "$DEPLOY_RESULT" = "skipped" ]; then
            STATUS="‚è≠Ô∏è SKIPPED"
            COLOR="warning"
          else
            STATUS="‚ùå FAILED"
            COLOR="danger"
          fi
          if [ -n "${SLACK_WEBHOOK_URL:-}" ]; then
            curl -X POST -H 'Content-type: application/json' \
            --data "{'text':'$STATUS: Scheduler Microservice Self-hosted Deploy','attachments':[{'color':'$COLOR','fields':[{'title':'Branch','value':'${{ github.ref_name }}','short':true},{'title':'Commit','value':'${{ github.sha }}','short':true},{'title':'Deploy Method','value':'Self-hosted Runner (No SSH)','short':true}]}]}" \
            $SLACK_WEBHOOK_URL || echo "Slack notification failed or webhook not configured"
          fi
          
          echo "üìã SELF-HOSTED DEPLOYMENT SUMMARY"
          echo "‚úÖ Build completed on GitHub runners"  
          echo "üöÄ Deploy executed directly on self-hosted Ubuntu runner"
          echo "üîê Azure Key Vault OIDC integration working"
          echo "üè∑Ô∏è Runner labels: [self-hosted, conexao-de-sorte-backend-scheduler]"
          echo ""
          if [ "$DEPLOY_RESULT" = "success" ]; then
            echo "üéâ Scheduler Microservice deployed successfully!"
            echo "üåê Service available at: scheduler.conexaodesorte.com.br"
          else
            echo "‚ùå Deployment failed - check self-hosted runner logs"
          fi