name: "‚è∞ Scheduler ‚Äì CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: "Destino do deploy"
        required: false
        default: "production"
        type: choice
        options: [ staging, production ]

# ----------------------------------------------------------------------
# PAR√ÇMETROS GERAIS
# ----------------------------------------------------------------------

env:
  SERVICE_NAME: scheduler
  TZ: America/Sao_Paulo

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: false

# ----------------------------------------------------------------------
# JOB 1 ‚ñ∏ VALIDA√á√ÉO DO WORKSPACE
# ----------------------------------------------------------------------

jobs:
  validate-environment:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: "Guard: validar configura√ß√µes obrigat√≥rias do Microservi√ßo"
        shell: bash
        run: |
          chmod +x .github/workflows/scripts/validate-required-files.sh
          ./.github/workflows/scripts/validate-required-files.sh microservice

      - name: "Guard: proibir r2dbc:h2 fora de testes"
        shell: bash
        run: |
          set -euo pipefail
          FOUND=$(grep -R --line-number --include='*.yml' --include='*.yaml' --include='*.properties' "r2dbc:h2" src || true)
          if echo "$FOUND" | grep -v "src/test/" | grep -q "r2dbc:h2"; then
            echo "‚ùå r2dbc:h2 encontrado fora de src/test" >&2
            echo "$FOUND" >&2
            exit 1
          fi

      - name: "Guard: depend√™ncia H2 n√£o‚Äëtest"
        shell: bash
        run: |
          ./mvnw -q dependency:list -DincludeScope=compile -DoutputFile=deps.txt
          if grep -E "com.h2database:h2|io.r2dbc:r2dbc-h2" deps.txt; then
            echo "‚ùå H2 presente em scope de produ√ß√£o" >&2
            exit 1
          fi

# ----------------------------------------------------------------------
# JOB 2 ‚ñ∏ BUILD + TEST + SAST/SCA
# ----------------------------------------------------------------------

  build-test-scan:
    needs: validate-environment
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - uses: actions/checkout@v4

      - name: Setup Java 24 (Temurin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "24"
          cache: maven

      - name: Build + Test + Package
        run: ./mvnw package

      - name: Upload JAR artefact
        uses: actions/upload-artifact@v4
        with:
          name: scheduler-jar
          path: target/*.jar
          retention-days: 1

# ----------------------------------------------------------------------
# JOB 3 ‚ñ∏ BUILD DA IMAGEM + PUSH GHCR
# ----------------------------------------------------------------------

  build-image:
    needs: [ build-test-scan, security-analysis ]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      image: ${{ steps.build.outputs.image }}
    permissions:
      packages: write
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Download JAR artefact
        uses: actions/download-artifact@v4
        with:
          name: scheduler-jar
          path: target

      # REMOVIDO: Azure CLI n√£o deve ser usado em produ√ß√£o
      # Scheduler usa apenas Docker Secrets sincronizados pela infraestrutura-core

      # ‚îÄ‚îÄ‚îÄ Login no GHCR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push Scheduler
        id: build
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          TIMESTAMP=$(date +'%d-%m-%Y-%H-%M')
          IMAGE=ghcr.io/$REPO_LOWER/conexao-de-sorte-backend-scheduler:${TIMESTAMP}
          IMAGE_LATEST=ghcr.io/$REPO_LOWER/conexao-de-sorte-backend-scheduler:latest

          # Build sem secrets (usa Docker Secrets em produ√ß√£o)
          docker buildx build \
            --tag "$IMAGE" \
            --tag "$IMAGE_LATEST" \
            --push \
            --provenance=true \
            --sbom=true \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --file Dockerfile .

          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"

# ----------------------------------------------------------------------
# JOB 3.5 ‚ñ∏ AN√ÅLISE DE SEGURAN√áA (similar aos demais servi√ßos)
# ----------------------------------------------------------------------

  security-analysis:
    needs: build-test-scan
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Verificar score de seguran√ßa do Microservi√ßo
        run: |
          chmod +x .github/workflows/scripts/security-analysis.sh
          ./.github/workflows/scripts/security-analysis.sh microservice 4

# ----------------------------------------------------------------------
# JOB 4 ‚ñ∏ DEPLOY SELF‚ÄëHOSTED (Docker Swarm + secrets)
# ----------------------------------------------------------------------

  deploy-selfhosted:
    needs: build-image
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-backend-scheduler]
    timeout-minutes: 8
    if: |
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'production'))
    permissions:
      id-token: write
      contents: read
      packages: read
    steps:
      - name: Login GHCR (Self-hosted)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}


      - name: Pull imagem do GHCR
        run: docker pull "${{ needs.build-image.outputs.image }}"

      # REMOVIDO: Azure Login - usar apenas Docker Secrets

      - name: Carregar todos os segredos do Azure Key Vault
        shell: bash
        run: |
          set -euo pipefail
          VAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          if [[ "$VAULT_ENDPOINT" =~ https://([^.]+)\.vault\.azure\.net ]]; then
            VAULT="${BASH_REMATCH[1]}"
          else
            echo "ERROR: Invalid AZURE_KEYVAULT_ENDPOINT format: $VAULT_ENDPOINT" >&2
            exit 1
          fi
          
          echo "üîê Loading all secrets from Azure Key Vault: $VAULT" >&2
          
          # SCHEDULER USA APENAS DOCKER SECRETS - Definir fallbacks seguros para vari√°veis n√£o-secret
          echo "üîê Scheduler configurado para usar apenas Docker Secrets em produ√ß√£o"

          # Vari√°veis n√£o-sens√≠veis com fallbacks seguros
          REDIS_HOST="redis"  # Nome do servi√ßo Docker
          REDIS_PORT="6379"
          REDIS_DATABASE="10"  # Database espec√≠fico do scheduler

          JWT_ISSUER="https://conexaodesorte.com.br"

          # Secrets sens√≠veis ser√£o injetados via Docker Secrets no runtime

          # Vari√°veis CORS com valores seguros
          CORS_ALLOWED_ORIGINS="https://conexaodesorte.com.br"
          CORS_ALLOW_CREDENTIALS="false"
          
          # Criar/atualizar Docker secrets com l√≥gica robusta
          # Se secret existe e servi√ßo est√° usando, precisa parar o servi√ßo primeiro
          if docker service ls --filter name="scheduler" --format '{{.Name}}' | grep -qx "scheduler"; then
            echo "‚ö†Ô∏è Servi√ßo scheduler j√° existe - removendo para atualizar secrets..."
            docker service rm scheduler || true
            sleep 5
          fi
          
          # Remover secrets antigos se existirem
          docker secret rm scheduler_redis_password 2>/dev/null || true
          docker secret rm scheduler_jwt_secret 2>/dev/null || true
          
          # O Scheduler usa apenas Docker Secrets criados pelo infraestrutura-core
          # Verificar se secrets essenciais j√° existem (criados pelo infraestrutura-core)
          if ! docker secret ls --filter name=REDIS_PASSWORD --format "{{.Name}}" | grep -q "REDIS_PASSWORD"; then
            echo "‚ö†Ô∏è Secret REDIS_PASSWORD n√£o encontrado - infraestrutura-core deve rodar primeiro"
            echo "üîÑ Continuando sem criar secrets locais (ser√£o injetados no runtime)"
          fi

          if ! docker secret ls --filter name=JWT_SECRET --format "{{.Name}}" | grep -q "JWT_SECRET"; then
            echo "‚ö†Ô∏è Secret JWT_SECRET n√£o encontrado - infraestrutura-core deve rodar primeiro"
            echo "üîÑ Continuando sem criar secrets locais (ser√£o injetados no runtime)"
          fi
          
          # Salvar vari√°veis de ambiente para o pr√≥ximo step
          echo "REDIS_HOST=$REDIS_HOST" >> $GITHUB_ENV
          echo "REDIS_PORT=$REDIS_PORT" >> $GITHUB_ENV
          echo "REDIS_DATABASE=$REDIS_DATABASE" >> $GITHUB_ENV
          echo "JWT_ISSUER=$JWT_ISSUER" >> $GITHUB_ENV
          echo "CORS_ALLOWED_ORIGINS=$CORS_ALLOWED_ORIGINS" >> $GITHUB_ENV
          echo "CORS_ALLOW_CREDENTIALS=$CORS_ALLOW_CREDENTIALS" >> $GITHUB_ENV

      - name: üßπ Cleanup existing deployment
        run: |
          # Remove stack existente se houver
          docker stack rm conexao-scheduler 2>/dev/null || true
          
          # Aguardar limpeza completa
          echo "‚è≥ Aguardando limpeza completa..."
          sleep 15
          
          # Limpar containers √≥rf√£os do servi√ßo scheduler
          docker container ls -q --filter "name=scheduler" | xargs -r docker stop
          docker container ls -aq --filter "name=scheduler" | xargs -r docker rm
          
          echo "‚úÖ Limpeza conclu√≠da"

      - name: Deploy via docker service (update/create)
        run: |
          set -euo pipefail
          IMAGE="${{ needs.build-image.outputs.image }}"
          SERVICE_NAME="${{ env.SERVICE_NAME }}"
          PORT=8084
          NETWORK_NAME="conexao-network-swarm"

          # Criar rede se n√£o existir
          docker network create --driver overlay "$NETWORK_NAME" 2>/dev/null || true

          echo "üîç Verificando se servi√ßo $SERVICE_NAME j√° existe..."
          if docker service ls --format '{{.Name}}' | grep -qx "$SERVICE_NAME"; then
            echo "üîÑ Servi√ßo j√° existe - executando UPDATE para nova imagem"
            timeout 60s docker service update \
              --image "$IMAGE" \
              --detach=false \
              --update-parallelism 1 \
              --update-delay 10s \
              "$SERVICE_NAME"
          else
            echo "üÜï Servi√ßo n√£o existe - executando CREATE"
            timeout 120s docker service create \
              --name "$SERVICE_NAME" \
              --network "$NETWORK_NAME" \
              --detach=false \
              --publish ${PORT}:8084 \
              --secret source=REDIS_HOST,target=REDIS_HOST \
              --secret source=REDIS_PORT,target=REDIS_PORT \
              --secret source=REDIS_PASSWORD,target=REDIS_PASSWORD \
              --secret source=REDIS_DATABASE,target=REDIS_DATABASE \
              --secret source=JWT_SECRET,target=JWT_SECRET \
              --secret source=JWT_ISSUER,target=JWT_ISSUER \
              --env SPRING_PROFILES_ACTIVE=prod,azure \
              --env TZ=America/Sao_Paulo \
              --env SERVER_PORT=8084 \
              --env SPRING_DATA_REDIS_HOST="${REDIS_HOST:-}" \
              --env SPRING_DATA_REDIS_PORT="${REDIS_PORT:-}" \
              --env SPRING_DATA_REDIS_DATABASE="${REDIS_DATABASE:-}" \
              --env JWT_ISSUER="${JWT_ISSUER:-}" \
              --env CORS_ALLOWED_ORIGINS="${CORS_ALLOWED_ORIGINS:-}" \
              --env CORS_ALLOW_CREDENTIALS="${CORS_ALLOW_CREDENTIALS:-}" \
              --env AZURE_CLIENT_ID="${{ secrets.AZURE_CLIENT_ID }}" \
              --env AZURE_TENANT_ID="${{ secrets.AZURE_TENANT_ID }}" \
              --env AZURE_KEYVAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}" \
              --env AZURE_KEYVAULT_ENABLED=true \
              "$IMAGE"
          fi

          # Verificar se deploy foi bem-sucedido
          echo "‚úÖ Verificando sa√∫de do servi√ßo..."
          sleep 10
          REPLICAS=$(docker service ls --filter name="$SERVICE_NAME" --format '{{.Replicas}}' | head -1 || echo "")
          if echo "$REPLICAS" | grep -q "1/1"; then
            echo "‚úÖ Deploy bem-sucedido!"
          else
            echo "‚ùå Falha no deploy - verificar logs"
            docker service logs "$SERVICE_NAME" --tail 50 || true
            exit 1
          fi

      - name: Aguardar Scheduler estar pronto
        run: |
          echo "‚è≥ Aguardando Scheduler ficar pronto..."
          TIMEOUT=180
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if docker service ls | grep -q "scheduler.*1/1"; then
              echo "‚úÖ Scheduler est√° pronto!"
              break
            fi
            echo "‚è≥ Aguardando readiness... ($ELAPSED/$TIMEOUT segundos)"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ùå Scheduler n√£o ficou pronto em $TIMEOUT segundos"
            echo "üìã Status dos servi√ßos:"
            docker service ls | grep scheduler || true
            echo "üìã Logs do Scheduler:"
            docker service logs conexao-scheduler_scheduler --tail 50 || true
            exit 1
          fi

      - name: Health‚Äëcheck Scheduler
        run: |
          echo "üîç Verificando sa√∫de do Scheduler..."
          docker service ls | grep scheduler
          
          # Teste do endpoint de health
          SERVICE_CONTAINER=$(docker ps --filter "name=scheduler" --format "{{.Names}}" | head -1 || echo "")
          if [ -n "$SERVICE_CONTAINER" ]; then
            echo "üåê Testando health endpoint..."
            docker exec "$SERVICE_CONTAINER" curl -f http://localhost:8080/actuator/health 2>/dev/null && echo "‚úÖ Scheduler health OK" || echo "‚ö†Ô∏è Scheduler health test failed"
          fi
          
          echo "üéâ Scheduler microservice deployment completed successfully!"
          echo "üåê API: https://scheduler.conexaodesorte.com.br"

# ----------------------------------------------------------------------
# JOB 5 ‚ñ∏ NOTIFY
# ----------------------------------------------------------------------

  notify:
    if: always()
    runs-on: ubuntu-latest
    needs: [ build-test-scan, deploy-selfhosted ]
    steps:
      - name: Slack notify
        env:
          WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          RESULT: ${{ needs.deploy-selfhosted.result }}
        shell: bash
        run: |
          if [ -z "$WEBHOOK" ]; then
            echo "‚ÑπÔ∏è Slack webhook n√£o configurado; etapa ignorada" && exit 0
          fi
          COLOR=good && [ "$RESULT" != "success" ] && COLOR=danger
          curl -X POST -H 'Content-type: application/json' \
               --data "{\"text\":\"Scheduler ‚Äì $RESULT\",\"attachments\":[{\"color\":\"$COLOR\"}]}" \
               "$WEBHOOK"
